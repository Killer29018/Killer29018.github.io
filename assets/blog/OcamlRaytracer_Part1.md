# Writing a software ray tracer in OCaml

Building a ray tracer is a great introduction to graphics, and even a basic
hobby ray tracer can provide great insight into how larger, commercial ray tracer's
work. A basic ray tracer can be simple enough that they can be implemented in nearly
every language, requiring only the ability to print out messages to form full
images using the [ppm](https://en.wikipedia.org/wiki/Netpbm) image format.

A great introduction into building a hobby ray tracer is following the
book series [ray tracing in one weekend](https://raytracing.github.io/) by Peter Shirley, Trevor D Black and
Steve Hollasch. The book series uses only c++ and the standard library which means
if you have never wrote a ray tracer but would like to find somewhere to start I
would highly recommend starting with this series, even only following the first book in the series is
a great introduction to the in-depth world of ray tracers.

With the help of that book series I decided a great way to learn [OCaml](https://ocaml.org/) was
by implementing a ray tracer. In particular this first part, in what is hopefully
a series of blogs, implements all the features from the [first book](https://raytracing.github.io/books/RayTracingInOneWeekend.html).
With that this blog will go over the basics of implementing a ray tracer in OCaml
and will highlight some of the positives to using a functional language.


## The beginning
The first step in implementing any ray tracer is being able to get an image of what
is being rendered. To begin I created two modules, one for a 3D vector, and one
for each pixel. The basic implementation of these two modules is as follows:

```ocaml
(* Vec3.mli *)
module Vec3 : sig
    type vec3 = {
        x: float;
        y: float;
        z: float;
    }

    val create : float -> float -> float -> vec3
end

(* Vec3.ml *)
module Vec3 = struct
    type vec3 = {
        x: float;
        y: float;
        z: float;
    }

    let create x y z =
        { x = x; y = y; z = z }
end
```

```ocaml
(* Pixels.mli *)
open Vec3
module Pixels : sig
    type pixel = {
        x: int;
        y: int;
        z: int;
    }

    val pixel_of_vec3 : Vec3.vec3 -> pixel
    val to_string : pixel -> string
end

(* Pixels.ml *)
open Vec3
module Pixels = struct
    type pixel = {
        x: int;
        y: int;
        z: int;
    }

    let pixel_of_vec3 (v : Vec3.vec3) =
        let x = int_of_float (v.x *. 255.) in
        let y = int_of_float (v.y *. 255.) in
        let z = int_of_float (v.z *. 255.) in
        { x = x; y = y; z = z }

    let to_string p =
        Printf.sprintf "%3d %3d %3d" p.x p.y p.z
end
```

Pixels is used as an intermediary between taking the colours generated by the ray tracer,
where each component has a value between 0-1, and the output required for the image
format where an 8 bit integer is required for each component.
